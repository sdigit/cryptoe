* Go through SHAd256 C code and rename things like BLOCK_SIZE/DIGEST_SIZE to remove ambiguity
* Same for NIST CTR_DRBG code, but probably less necessary
* C cleanup in general
* Incorporate crypto.Random.DRBG into crypto.Random._ParanoidRNG when it is detected
* Derive a MAC key from PBKDF2 output, use it for integrity checking of salts
* Now that the basic key database works, extend it to store cipher metadata (bytes encrypted with a key, times a key has been used)
* Have the DB initialization also derive a seed value for IVs, and store IVs used in encrypted form

* Cipher support:
 * Add interface for data encryption, namely files and arbitrary strings.
  * Start with (Cipher)-CBC and/or (Cipher)-CTR for confidentiality with HMAC-SHAd256 for authentication
  * Once that works, add GCM (and once GCM is tested, use GCM by default)

* KMS API:
 * Add a default expiration to the database keys table
 * Create a class for requesting a key from the keystore
